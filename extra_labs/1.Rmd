---
title: "Enhancing Lattice Graphics"
author:
date: The following slides contain **new** commands that can be used to enhance the lattice graphics used in the IDS Course.
output:
  slidy_presentation: default
  pdf_document: default
---

```{r setup, include=FALSE}
```

```{r, eval=TRUE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
library(mobilizr)
library(readr)
# colors <- read_csv("colors.csv")
colors <- extra_data("colors_ids")
colors <- colors_ids
```

## Titles and axes

-   The following <b>arguments</b> control the titles and axes for lattice plots.

-   `main` &emsp; Adds a title to your visual

-   `sub` &emsp; Adds a subtitle to your visual

-   `xlab` &emsp; Changes the label on the x-axis

-   `ylab` &emsp; Changes the label on the y-axis

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
bargraph(~drink_water, data=cdc, 
         main = "Are US Teens Drinking Enough Water?",
         sub ="CDC Youth Risk Behaviour Survey",
         xlab = "How often teens consumed water over the past 7 days",
         ylab = "Number of teens")
```

## Color & bargraphs

-   `col` &emsp; Changes the color of your visual

-   Click <b><a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf"  target="_blank">here</a></b> to see the colors that are available!

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
bargraph(~asthma, data=cdc,
          col = "mistyrose")
```

-  Sometimes we want to assign different colors to the bars in a bargraph. Utilizing the `groups` and `stack` arguments will allow us to do this. Let's try this with the asthma variable. The asthma variable has three categories so we need to choose three colors for our plot.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
bargraph(~asthma, data=cdc,
         groups = asthma,
         # assigned to the bars in the order they appear
         col=c("red2","pink","white"),
         stack = "TRUE")
```

## Colored lines

-  Create a histogram of `height` from the `cdc` data. Add vertical lines representing the mean and median of the data.
-  Can you discern between mean and median?
-  The `col` argument can be used in the `add_line` function to control the color of lines.
-  Copy and paste the code below to color the mean line black and the median line red.

```{r, eval = FALSE, echo = TRUE, fig.height=4, fig.width=5, warning=FALSE}
add_line(vline = mean(~height,data=cdc), col="black")
add_line(vline = median(~height,data=cdc), col="red")
```

## Legends

- Although you might know the meaning of the chosen colors, your audience does not. The `key` argument is used to create a legend.

```{r, eval = FALSE, echo = TRUE, fig.height=4, fig.width=5, warning=FALSE}
histogram(~height, data=cdc,
          col = "beige",
          # space argument determines where your key is placed - "right", "left", "top", "bottom"
          key=list(space="right",
                   # color coding the lines and managing width in the key
                   lines=list(col=c("black","red"), lwd=3),
                   # labels for the lines in the key
                   text=list(c("mean","median"))))
add_line(vline = mean(~height,data=cdc), col="black")
add_line(vline = median(~height,data=cdc), col="red")
```

```{r, eval = TRUE, echo = FALSE, fig.height=4, fig.width=5, warning=FALSE,include=FALSE}
histogram(~height, data=cdc,
          col = "beige",
          key=list(space="right",
                   lines=list(col=c("black","red"), lwd=3),
                   text=list(c("mean","median"))))
add_line(vline = mean(~height,data=cdc), col = "black")
```

```{r, eval = TRUE, echo = FALSE, fig.height=4, fig.width=5, warning=FALSE}
add_line(vline = median(~height,data=cdc), col="red")
```

## Histograms and scales

-   When creating a histogram, it can be frustrating trying to estimate the values on the x-axis. A solution is including the `scales` argument.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram(~weight, data=cdc)
```


```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram(~weight, data=cdc,
          # seq(from, to, by) tick marks beginning at 10 kg up to 180 kg by 20s
         scales=list(x=list(at=seq(10,180,20)),
                     # you can also choose specific values
                     y=list(at=c(0, 2000, 4000))
                     )
         )
```

## Histograms and breaks

-   While the scales argument helped tremendously we can make the axes more readable by including the `breaks` argument along with the `scales` argument.

-   We need to check the min and max values of the variable we are going to plot when using the `breaks` argument because they need to be included within the range of values.

```{r, warning=FALSE}
range(~weight, data=cdc)
```

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram(~weight, data=cdc,
          # notice that 27.22 kg and 180.99 kg are included in the interval (25,185)
          breaks = seq(25,185,20))
```

-   Including the scales argument to include labels at each break makes the plot more readable.


```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram(~weight, data=cdc,
          breaks = seq(25,185,20),
          scales=list(x=list(at=seq(25,185,20))))
```

## Zooming in on the axis

-   Distributions that are skewed or that contain outliers, can also impact the readability of a plot.
The `xlim` argument allows you to control the lower and upper limits of the x-axis.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram (~weight, data=cdc)
```

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
histogram (~weight, data=cdc, xlim=c(30,160))
```

-   There is also a `ylim` argument.


## Dotplots

-   Dotplots are more appropriate for small data sets. Since most of our pre-loaded data sets are very large, we are going to create a vector with toy data. Copy and paste the code below in your console or an RScript.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
# will appear in your Environment Pane as Values
x <- c(5,5,6,7,8,8,8,9,10,10)
```

-   Now that we have a vector of numerical values, we can make a dotplot. Since the values are not a variable in a data frame, you do not need the tilde (~) in your command.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
# the nint was max minus min plus one (10 - 5 + 1)
dotPlot(x, nint = 6)
```


-   The default plot character for a dotPlot is a dot but you can change that using the `pch` argument. Recall that you can also change the size of the characters with the `cex` argument.

```{r, eval = TRUE, echo = TRUE, fig.height=4, fig.width=5}
dotPlot(x, nint = 6, pch = 2, cex = 0.5)
```

<table>
  <tr>
    <th>pch value</th>
    <th>shape</th>
  </tr>
  <tr>
    <td>0</td>
    <td>square</td>
  </tr>
    <tr>
    <td>1</td>
    <td>circle</td>
  </tr>
  <tr>
    <td>2</td>
    <td>triangle</td>
  </tr>
  </tr>
  <tr>
    <td>3</td>
    <td>plus</td>
  </tr>
  </tr>
  <tr>
    <td>4</td>
    <td>cross</td>
  </tr>
  </tr>
  <tr>
    <td>5</td>
    <td>diamond</td>
  </tr>
  </tr>
  <tr>
    <td>6</td>
    <td>triangle point down</td>
  </tr>
  </tr>
  <tr>
    <td>7</td>
    <td>square cross</td>
  </tr>
</table>

## Comparing plots

-   Did you ever want to view the distribution of all of the color scores at the same time?

-   If you do not have the colors data loaded on your _Environment_, do not worry, run the following code on your console:

```{r, eval = FALSE, echo = TRUE}
extra_data('colors_ids')
```

-   Now that you have the data, follow the steps below:

-   Step 1: Store all of the plots you want to include

```{r, eval = TRUE, echo = TRUE}
# these should appear in your Environment pane as a List
plot1<-bwplot(~blue, data = colors_ids, col ="blue")
plot2<-bwplot(~gold, data = colors_ids, col ="gold")
plot3<-bwplot(~green, data = colors_ids, col ="green", xlim=c(4, 21))
plot4<-bwplot(~orange, data = colors_ids, col ="orange")
```

-   Step 2: Use the `grid.arrange` from the gridExtra Package

```{r, eval = TRUE, echo = TRUE, fig.height=6, fig.width=5 }
gridExtra::grid.arrange(plot1, plot2, plot3, plot4, nrow = 4)
```

Note: You might need to click on the zoom button to see all 4 boxplots.